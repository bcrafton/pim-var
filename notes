
> how does shifting work ? 
  > filter2pcm gives float
  > dot = patch_xb @ f_wb
  > adc(dot = patch_xb @ f_wb)
  
> so we want to come up with good: rows_per_read
to do so, we just need to figure out which it screws up on.

rows_per_read_table = {}
rows_per_read_table[(1, 1)] = 16
rows_per_read_table[(1, 2)] = 16
rows_per_read_table[(1, 3)] = 4
rows_per_read_table[(1, 4)] = 4

rows_per_read_table[(2, 1)] = 16
rows_per_read_table[(2, 2)] = 4
rows_per_read_table[(2, 3)] = 4
rows_per_read_table[(2, 4)] = 4

rows_per_read_table[(3, 1)] = 16
rows_per_read_table[(3, 2)] = 4
rows_per_read_table[(3, 3)] = 4
rows_per_read_table[(3, 4)] = 4

rows_per_read_table[(4, 1)] = 4
rows_per_read_table[(4, 2)] = 4
rows_per_read_table[(4, 3)] = 4
rows_per_read_table[(4, 4)] = 4

------

also, we shud not be relying on random distribution to hold
we need to work with distributions.
its a more robust idea.

steps:
1) fix ADC
2) highlight which [xb, wb] caused the problem
3) try to make distributions work
> instead of count_nonzero(y1 == y2)
> expected number of errors * size of error


